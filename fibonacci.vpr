/*
 * CHALLENGE 1
 * The Viper code below shows a method that recursively computes the n-th Fibonacci number. 
 * First, prove functional correctness, i.e. that the method indeed returns the n-th Fibonacci number.
 * After that, find the smallest upper bound on the method's runtime in our runtime model.
 * Finally, prove that your bound is indeed the smallest upper bound on the method's runtime.
 */


// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------


// -----------------------------------------
// Task 1: Prove a runtime bound for the following recursive method
// Your bound should be tight, i.e. use as few time credits
// as possible. Furthermore, prove that it is not possible
// to use fewer time credits.
// Do not modify the given production code. However, feel free to 
// introduce additional functions, lemma methods or ghost code.
// Furthermore, make sure that the functional contract remains intact.
// -----------------------------------------
// Mathematical specification

// fib_math(n): standard mathematical Fibonacci function
// - Returns F(n) where F(0) = 0, F(1) = 1 and
//   F(n) = F(n-1) + F(n-2) for n >= 2.
// - Serves as the functional specification that `fib_recursive`
//   must satisfy (i.e., the method should return fib_math(n)).
function fib_math(n: Int): Int
    requires n >= 0
{
    n <= 1 ? n : fib_math(n - 1) + fib_math(n - 2)
}

// Runtime cost specification - tight bound
// fib_cost(n): minimal number of abstract time units (time credits)
// required to execute `fib_recursive(n)` under the runtime model.
// - Each non-ghost method invocation consumes one time credit
//   via `consume_time_credit()` at its start.
// - Base cases (n = 0 or 1) consume exactly 1 credit.
// - For n >= 2, one credit is consumed for the current call
//   plus the credits required by the two recursive calls,
//   hence fib_cost(n) = 1 + fib_cost(n-1) + fib_cost(n-2).
// This function is intended to be the tight (smallest) upper bound
// on the runtime of `fib_recursive` in the given model.
function fib_cost(n: Int): Int
    requires n >= 0
    ensures result >= 1
{
    n <= 1 ? 1 : 1 + fib_cost(n - 1) + fib_cost(n - 2)
}

// Main implementation with proven tight runtime bound
method fib_recursive(n: Int) returns (res: Int)
    requires n >= 0  // input must be non-negative
    // TODO add time credits and functional specification
    //requires time_credit() x fib_cost(n) times
    requires acc(time_credit(), fib_cost(n)/1) // provide enough time credits
    // Smallest / tight upper bound on the method's runtime
    // tests:
    //requires acc(time_credit(), (fib_cost(n)-1)/1) // not enough -> consume_time_credits
    //requires acc(time_credit(), (fib_cost(n)+1)/1) // too many -> problem in recursive calls
    ensures res == fib_math(n) // functional correctness
{
    consume_time_credit() // we must spend a credit for every call

    if (n == 0) {
        res := 0
    } elseif (n == 1) {
        res := 1
    } else {
        var sub1: Int
        sub1 := fib_recursive(n - 1)
        var sub2: Int
        sub2 := fib_recursive(n - 2)
        
        res := sub1 + sub2
    }

    //  Proof: smallest upper bound on the method's runtime
    exhale perm(time_credit()) == none // 1/1 //give back unused time credit
}

// test main method
method main()

{
    //TODO: make tests for fib_recursive
    var a: Int
    //a := fib_recursive(5)

    //assert a == 5
    //assert fib_recursive(0) == 0
    //assert fib_recursive(1) == 1
    //assert false
}


// Verified with both carbon and silicon