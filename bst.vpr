// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------

field min_val: Int // ghost field for min value in the tree
field max_val: Int // ghost field for max value in the tree

// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------

// Helper
function get_node_min(n: Ref): Int
    requires acc(bst_node(n))
{
    unfolding bst_node(n) in n.min_val
}

function get_node_max(n: Ref): Int
    requires acc(bst_node(n))
{
    unfolding bst_node(n) in n.max_val
}

function get_node_elem(n: Ref): Int
    requires acc(bst_node(n))
{
    unfolding bst_node(n) in n.elem
}


// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref) // TODO
{
    acc(self.root) && // + access to root field
    // allow empty tree: (self.root == null || bst_node(self.root))
    (self.root != null ==> bst_node(self.root))
}   

// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref) // TODO
{
    // NO DUPLICATES + RECURSIVE BST: bst(self.left) &&  bst(self.right) 
    acc(self.elem) && acc(self.left) && acc(self.right) &&
    
    // forall without ghost arguments --> slow
    acc(self.min_val) && acc(self.max_val) &&

    // bounds on min and max values
    self.min_val <= self.elem && self.elem <= self.max_val &&

    // optional left and right subtree + bst property
    (self.left != null ==> acc(bst_node(self.left))) &&
    (self.right != null ==> acc(bst_node(self.right))) &&

    // all nodes values in left subtree < (stricly smaller) current node value
    //(self.left != null ==> (forall x: Int :: x in to_set_node(self.left) ==> x < self.elem)) &&
    (self.left != null ==> get_node_max(self.left) < self.elem && 
                            self.min_val == get_node_min(self.left)) &&
    (self.left == null ==> self.min_val == self.elem) &&

    // all nodes values in right subtree > (stricly greater) current node value
    //(self.right != null ==> (forall x: Int :: x in to_set_node(self.right) ==> x > self.elem))
    (self.right != null ==> get_node_min(self.right) > self.elem && 
                            self.max_val == get_node_max(self.right)) &&
    (self.right == null ==> self.max_val == self.elem)
}
// -----------------------------------------


// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method
method bst_insert(tree: Ref, val: Int)
    requires bst(tree)
    // TODO
    // TASK 4.3 time credit =  at most height(tree) + c (constant, typically 1 or 2)
    requires height(tree) + 1 >= 0 // permissions not negative
    requires acc(time_credit(), (height(tree)+1)/1) //++ 
    // requires acc(time_credit(), height(tree) +c)
    //  (height(tree)) 
    //  (height(tree) + 1) 
    //  (height(tree) + 2) // max nr recursive calls + 1 bst_insert + 1 deepest insert_rec

    // if balanced input tree, then O(log n), n total nr of nodes
    // if unbalanced input tree, then O(n), n total nr of nodes

    // TASK 4.2: insertion preserves bst property
    // TASK 4.2: memory safety - fold/unfold + access permissions
    ensures bst(tree) // ++  

    // TASK 4.4 set of values
    ensures to_set(tree) == old(to_set(tree)) union Set(val) //++
    ensures height(tree) <= old(height(tree)) + 1 //++

{
    consume_time_credit() // spend one time credit for the current call 4.3
    unfold bst(tree)

    if (tree.root == null){// insert new node as root
        var new_node: Ref := new(elem, left, right, min_val, max_val)
        new_node.elem := val
        new_node.left := null
        new_node.right := null
        new_node.min_val := val // ghost field *
        new_node.max_val := val // ghost field *

        tree.root := new_node
        fold bst_node(new_node)   
    }
    else{   // non-empty tree
        insert_rec(tree.root, val)
        // tree.root := new_root
    }
    fold bst(tree) // folding back the bst predicate
    exhale perm(time_credit()) == 0/1 // none // 1/1 // give back unused time credit
}

method insert_rec(tree: Ref, val: Int) 
    requires acc(bst_node(tree))    //requires bst_node(tree)
    requires acc(time_credit(), (height_node(tree))/1) //++
    
    ensures acc(bst_node(tree))     //ensures bst_node(tree)
    
    ensures get_node_min(tree) == min(old(get_node_min(tree)), val)
    ensures get_node_max(tree) == max(old(get_node_max(tree)), val)
    
    ensures to_set_node(tree) == old(to_set_node(tree)) union (Set(val))
    ensures height_node(tree) <= old(height_node(tree)) + 1

{
    consume_time_credit() // spend one time credit for the current call 4.3
    unfold bst_node(tree)
    
    var curr: Int := tree.elem

    if (val == curr) { // no duplicates
        // do nothing - it already exists
    }
    elseif(val < curr){ // left
        if (tree.left == null){ // insert new node as left child
            var new_node: Ref := new(elem, left, right, min_val, max_val)
            new_node.elem := val
            new_node.left := null
            new_node.right := null
            new_node.min_val := val // ghost field *
            new_node.max_val := val // ghost field *
            fold bst_node(new_node)  

            tree.left := new_node
        }
        else { // recursively insert in left subtree
            insert_rec(tree.left, val)
            //tree.left := new_left
        }
    } else {
        // (val > curr) // right
        if (tree.right == null) {
            // insert new node as right child
            var new_node: Ref := new(elem, left, right, min_val, max_val)
            new_node.elem := val
            new_node.left := null
            new_node.right := null
            new_node.min_val := val // ghost field *
            new_node.max_val := val // ghost field *

            fold bst_node(new_node)  
            tree.right := new_node
        } else {
            // recursively insert in right subtree
            insert_rec(tree.right, val)
        }
    }
    var min_r : Int := tree.elem
    var max_r : Int := tree.elem
    if (tree.left != null) {
        var left_min : Int := get_node_min(tree.left) // tree.left.min_val
        
        min_r := min(min_r, left_min)
    }
    if (tree.right != null) {
        var right_max : Int := get_node_max(tree.right) // tree.right.max_val
        
        max_r := max(max_r, right_max)
    }
    tree.min_val := min_r
    tree.max_val := max_r

    // restore node predicate before folding the whole tree
    fold bst_node(tree)
    //res := tree
}
// -----------------------------------------



// -----------------------------------------
// Auxiliary definition of the height of a tree
// heap dependent function (recursive)
function height(tree: Ref) : Int
    requires bst(tree)
    ensures result >= 0
    // TODO: define for TASK 4.3
{
    unfolding bst(tree) in 
        (tree.root == null ? 0 : 
        height_node(tree.root))
}

function height_node(node: Ref) : Int
    requires bst_node(node) //requires acc(bst_node(n))
    ensures result >= 1
{
    //1 + max(height(node.left), height(node.left)))
    unfolding bst_node(node) in 
    (1 + max(
        (node.left == null ? 0 : height_node(node.left)), 
        (node.right == null ? 0 : height_node(node.right))
    ))
}
// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
// heap dependent function (recursive)
function to_set(tree: Ref): Set[Int]
    // TODO: define for TASK 4.4
    requires bst(tree)
    // init_Set U {new_value}
{
    unfolding bst(tree) in 
        (tree.root == null ? 
        Set[Int]() : to_set_node(tree.root))
}

function to_set_node(node: Ref): Set[Int]
    requires bst_node(node)
{
    //  Set[Int]() : to_set_node(node.left) union Set(node.elem) union to_set_node(node.right))
    unfolding bst_node(node) in 
        (
        (node.left == null ? Set[Int]() : 
            to_set_node(node.left) ) 
        union Set(node.elem) 

        union (node.right == null ? Set[Int]() : 
            to_set_node(node.right) )
        )
    
}
// -----------------------------------------

method example_usage()
    requires acc(time_credit(), 6/1)
{
    var tree: Ref := new(root)
    tree.root := null
    fold bst(tree)

    bst_insert(tree, 10) // needs height 0 + 1 = 1 credit
    assert perm(time_credit()) == 5/1 // 

    assert 10 in to_set(tree)
    assert !(5 in to_set(tree))

    bst_insert(tree, 5) // needs height 1 + 1 = 2 credits
    assert perm(time_credit()) == 3/1
    assert 10 in to_set(tree)
    assert 5 in to_set(tree)

    bst_insert(tree, 15) // needs height 2 + 1 = 3 credits
    assert perm(time_credit()) == none // 0/1
    assert 10 in to_set(tree)
    assert 5 in to_set(tree)
    assert 15 in to_set(tree)       
}