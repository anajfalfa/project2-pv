// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------


// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------

// -----------------------------------------
// Ghost field - TASK 4.1 + 4.4
field set: Set[Int] // set of all values in the BST rooted at this node
// -----------------------------------------

// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref) // TODO
{
    acc(self.root) && // + access to root field
    // allow empty tree: (self.root == null || bst_node(self.root))
    (self.root != null ==> bst_node(self.root))
}   

// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref) // TODO
{
    // NO DUPLICATES + RECURSIVE BST: bst(self.left) &&  bst(self.right) 
    acc(self.elem) && acc(self.left) && acc(self.right) &&
    
    // forall without ghost arguments --> slow

    // optional left and right subtree + bst property
    (self.left != null ==> bst_node(self.left)) &&
    (self.right != null ==> bst_node(self.right)) &&

    // all nodes values in left subtree < (stricly smaller) current node value
    (self.left != null ==> (forall x: Int :: x in to_set_node(self.left) ==> x < self.elem)) &&
    
    // all nodes values in right subtree > (stricly greater) current node value
    (self.right != null ==> (forall x: Int :: x in to_set_node(self.right) ==> x > self.elem))
}

// -----------------------------------------


// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method
method bst_insert(tree: Ref, val: Int)
    requires bst(tree)
    // TODO
    // TASK 4.3 time credit =  at most height(tree) + c (constant, typically 1 or 2)
    // requires acc(time_credit(), height(tree) +c) // where???
    requires height(tree) + 1 >= 0 // permissions not negative
    requires acc(time_credit(), (height(tree)+1)/1) //++ 
    //  (height(tree)) 
    //  (height(tree) + 1) 
    //  (height(tree) + 2) // max nr recursive calls + 1 bst_insert + 1 deepest insert_rec

    // if balanced input tree, then O(log n), n total nr of nodes
    // if unbalanced input tree, then O(n), n total nr of nodes

    // ! memory safety
    ensures bst(tree) // ++ 4.2 preserves BST property 

    // TASK 4.4 set of values
    ensures to_set(tree) == to_set(old(tree)) union Set(val) //++
    ensures height(tree) <= old(height(tree)) + 1 //++

{
    consume_time_credit() // spend one time credit for the current call 4.3
    unfold bst(tree)

    if (tree.root == null)
    {
        // consume_time_credit()
        // insert new node as root
        var new_node: Ref := new(elem, left, right)
        new_node.elem := val
        new_node.left := null
        new_node.right := null

        tree.root := new_node

        fold bst_node(new_node)   
    }
    else{   // non-empty tree
        var new_root: Ref
        new_root := insert_rec(tree.root, val)
        tree.root := new_root
    }
    // folding
    fold bst(tree)

}

method insert_rec(tree: Ref, val: Int) returns (res: Ref)
    requires bst_node(tree)
    // TODO time credits for TASK 4.3
    requires acc(time_credit(), (height_node(tree))/1) //++
    ensures bst_node(tree)
    ensures res == tree
    ensures to_set_node(res) == old(to_set_node(tree)) union (Set(val))
    ensures height_node(res) <= old(height_node(tree)) + 1
{
    //consume_time_credit() // spend one time credit for the current call 4.3
    unfold bst_node(tree)
    res := tree
    
    var curr: Int := tree.elem

    if (val == curr) { // -- no duplicates
        // do nothing - it already exists
    }
    elseif(val < curr){ // left
        if (tree.left == null){
            // insert new node as left child
            var new_node: Ref := new(elem, left, right)
            new_node.elem := val
            new_node.left := null
            new_node.right := null
            fold bst_node(new_node)  

            tree.left := new_node
        }
        else {
            // recursively insert in left subtree
            var new_left: Ref // **
            new_left := insert_rec(tree.left, val)
            tree.left := new_left
        }
    } else {
        // (val > curr) // right
        if (tree.right == null) {
            // insert new node as right child
            var new_node: Ref := new(elem, left, right)
            new_node.elem := val
            new_node.left := null
            new_node.right := null

            fold bst_node(new_node)  
            tree.right := new_node
        } else {
            // recursively insert in right subtree
            var new_right: Ref
            new_right := insert_rec(tree.right, val)
            tree.right := new_right
        }
    }
    fold bst_node(tree)
    // restore node predicate before folding the whole tree
}
// -----------------------------------------



// -----------------------------------------
// Auxiliary definition of the height of a tree
// --> 4.3
// heap dependent function (recursive)
function height(tree: Ref) : Int
    requires bst(tree)
    ensures result >= 0
    // TODO: define for TASK 4.3
{
    unfolding bst(tree) in 
    (tree.root == null ? 0 : 
    height_node(tree.root))
    //1 + max(height(tree.root.left), height(tree.root.left)))
}

function height_node(node: Ref) : Int
    requires bst_node(node)
    ensures result >= 1
{
    unfolding bst_node(node) in 
    (1 + max(
        (node.left == null ? 0 : height_node(node.left)), 
        (node.right == null ? 0 : height_node(node.right))
    ))
}
// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
// heap dependent function (recursive)
function to_set(tree: Ref): Set[Int]
    requires bst(tree)
    //requires acc(tree.root)
    //requires tree.root != null ==> acc(tree.root.elem) && acc(tree.root.left) && acc(tree.root.right) && bst(tree.root)
    // TODO: define for TASK 4.4
    // init_Set U {new_value}
    //    ensures bst(tree)
// -----------------------------------------
{
    unfolding bst(tree) in 
        (tree.root == null ? 
        Set[Int]() : to_set_node(tree.root))
}

function to_set_node(node: Ref): Set[Int]
    requires bst_node(node)
{
//  Set[Int]() : to_set_node(tree.root.left) union Set(tree.root.elem) union to_set_node(tree.root.right))

    unfolding bst_node(node) in 
        (node.left == null ? Set[Int]() : 
        to_set_node(node.left)        
        //(unfolding bst_node(node.left) in to_set_node(node.left)))
        ) 
        union Set(node.elem) 
        union (node.right == null ? Set[Int]() : 
        to_set_node(node.right)
        //(unfolding bst_node(node.right) in to_set_node(node.right)))
        )
}