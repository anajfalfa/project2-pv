// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------


// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------


// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref) // TODO
    // edited aa
{
    acc(self.root) && 
    (self.root != null  ==> acc(self.root.elem) && acc(self.root.left) && acc(self.root.right) &&
                            (self.root.left != null ==> acc(self.root.left.elem) && self.root.elem > self.root.left.elem) &&
                            (self.root.right != null ==>  acc(self.root.left.elem) && self.root.elem > self.root.right.elem))
    // RECURSIVE BST
    // bst(self.root.left)
    // bst(self.root.right) 
}   

// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref) // TODO

// -----------------------------------------


// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method
method bst_insert(tree: Ref, val: Int)
    requires bst(tree)
    ensures bst(tree) // preserves BST property -added aa
    // TODO
    // time and height
{
    unfold bst(tree)
    // case null?
    var curr: Int := tree.root.elem

    if(val < curr)
    { // left
    }
    if (val > curr)
    {
        // right
    }
    // val == curr? 
    fold bst(tree)

}

// -----------------------------------------



// -----------------------------------------
// Auxiliary definition of the height of a tree
// --> 4.3
function height(tree: Ref) : Int
    requires bst(tree)
    // TODO: define for TASK 4.3

    // requires acc(time_credit(), height(tree) +c) // where???
// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
function to_set(tree: Ref): Set[Int]
    // TODO: define for TASK 4.4
    // init_Set U {new_value}
// -----------------------------------------

